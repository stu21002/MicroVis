// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.12.4
// source: defs.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "proto";

export enum RegionType {
  POINT = 0,
  LINE = 1,
  RECTANGLE = 2,
  CIRCLE = 3,
  UNRECOGNIZED = -1,
}

export function regionTypeFromJSON(object: any): RegionType {
  switch (object) {
    case 0:
    case "POINT":
      return RegionType.POINT;
    case 1:
    case "LINE":
      return RegionType.LINE;
    case 2:
    case "RECTANGLE":
      return RegionType.RECTANGLE;
    case 3:
    case "CIRCLE":
      return RegionType.CIRCLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RegionType.UNRECOGNIZED;
  }
}

export function regionTypeToJSON(object: RegionType): string {
  switch (object) {
    case RegionType.POINT:
      return "POINT";
    case RegionType.LINE:
      return "LINE";
    case RegionType.RECTANGLE:
      return "RECTANGLE";
    case RegionType.CIRCLE:
      return "CIRCLE";
    case RegionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FileInfo {
  name: string;
  /** FileType type = 2; Assume HDF5 */
  size: number;
  /** Note sure what goes here */
  HDUList: string[];
  date: number;
}

export interface FileInfoExtended {
  /** Number of dimensions of the image file */
  dimensions: number;
  /** Width of the XY plane */
  width: number;
  /** Height of the XY plane */
  height: number;
  /** Number of channels */
  depth: number;
  /** Number of Stokes parameters */
  stokes: number;
}

export interface Empty {
}

export interface StatusResponse {
  status: boolean;
  statusMessage: string;
}

function createBaseFileInfo(): FileInfo {
  return { name: "", size: 0, HDUList: [], date: 0 };
}

export const FileInfo = {
  encode(message: FileInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.size !== 0) {
      writer.uint32(25).sfixed64(message.size);
    }
    for (const v of message.HDUList) {
      writer.uint32(34).string(v!);
    }
    if (message.date !== 0) {
      writer.uint32(41).sfixed64(message.date);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.size = longToNumber(reader.sfixed64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.HDUList.push(reader.string());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.date = longToNumber(reader.sfixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      HDUList: globalThis.Array.isArray(object?.HDUList) ? object.HDUList.map((e: any) => globalThis.String(e)) : [],
      date: isSet(object.date) ? globalThis.Number(object.date) : 0,
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.HDUList?.length) {
      obj.HDUList = message.HDUList;
    }
    if (message.date !== 0) {
      obj.date = Math.round(message.date);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileInfo>, I>>(base?: I): FileInfo {
    return FileInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileInfo>, I>>(object: I): FileInfo {
    const message = createBaseFileInfo();
    message.name = object.name ?? "";
    message.size = object.size ?? 0;
    message.HDUList = object.HDUList?.map((e) => e) || [];
    message.date = object.date ?? 0;
    return message;
  },
};

function createBaseFileInfoExtended(): FileInfoExtended {
  return { dimensions: 0, width: 0, height: 0, depth: 0, stokes: 0 };
}

export const FileInfoExtended = {
  encode(message: FileInfoExtended, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dimensions !== 0) {
      writer.uint32(13).sfixed32(message.dimensions);
    }
    if (message.width !== 0) {
      writer.uint32(21).sfixed32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(29).sfixed32(message.height);
    }
    if (message.depth !== 0) {
      writer.uint32(37).sfixed32(message.depth);
    }
    if (message.stokes !== 0) {
      writer.uint32(45).sfixed32(message.stokes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileInfoExtended {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfoExtended();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.dimensions = reader.sfixed32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.width = reader.sfixed32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.height = reader.sfixed32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.depth = reader.sfixed32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.stokes = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfoExtended {
    return {
      dimensions: isSet(object.dimensions) ? globalThis.Number(object.dimensions) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
      stokes: isSet(object.stokes) ? globalThis.Number(object.stokes) : 0,
    };
  },

  toJSON(message: FileInfoExtended): unknown {
    const obj: any = {};
    if (message.dimensions !== 0) {
      obj.dimensions = Math.round(message.dimensions);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    if (message.stokes !== 0) {
      obj.stokes = Math.round(message.stokes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileInfoExtended>, I>>(base?: I): FileInfoExtended {
    return FileInfoExtended.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileInfoExtended>, I>>(object: I): FileInfoExtended {
    const message = createBaseFileInfoExtended();
    message.dimensions = object.dimensions ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.depth = object.depth ?? 0;
    message.stokes = object.stokes ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseStatusResponse(): StatusResponse {
  return { status: false, statusMessage: "" };
}

export const StatusResponse = {
  encode(message: StatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== false) {
      writer.uint32(8).bool(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(18).string(message.statusMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusResponse {
    return {
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
    };
  },

  toJSON(message: StatusResponse): unknown {
    const obj: any = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusResponse>, I>>(base?: I): StatusResponse {
    return StatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusResponse>, I>>(object: I): StatusResponse {
    const message = createBaseStatusResponse();
    message.status = object.status ?? false;
    message.statusMessage = object.statusMessage ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
