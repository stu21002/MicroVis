"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.12.4
// source: H5Readers.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.H5ReadersClient = exports.H5ReadersService = exports.SpatialProfile = exports.HistogramResponse = exports.HistogramDistRequest = exports.HistogramRequest = exports.SpectralProfileResponse = exports.SpectralProfileRequest = exports.Mask = exports.ImageDataResponse = exports.ImageDataRequest = exports.StatusResponse = exports.Empty = exports.RegionType = exports.protobufPackage = void 0;
exports.regionTypeFromJSON = regionTypeFromJSON;
exports.regionTypeToJSON = regionTypeToJSON;
/* eslint-disable */
const grpc_js_1 = require("@grpc/grpc-js");
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const FileInfo_1 = require("./FileInfo");
const OpenFile_1 = require("./OpenFile");
exports.protobufPackage = "proto";
var RegionType;
(function (RegionType) {
    RegionType[RegionType["POINT"] = 0] = "POINT";
    RegionType[RegionType["LINE"] = 1] = "LINE";
    RegionType[RegionType["RECTANGLE"] = 2] = "RECTANGLE";
    RegionType[RegionType["CIRCLE"] = 3] = "CIRCLE";
    RegionType[RegionType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RegionType || (exports.RegionType = RegionType = {}));
function regionTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "POINT":
            return RegionType.POINT;
        case 1:
        case "LINE":
            return RegionType.LINE;
        case 2:
        case "RECTANGLE":
            return RegionType.RECTANGLE;
        case 3:
        case "CIRCLE":
            return RegionType.CIRCLE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RegionType.UNRECOGNIZED;
    }
}
function regionTypeToJSON(object) {
    switch (object) {
        case RegionType.POINT:
            return "POINT";
        case RegionType.LINE:
            return "LINE";
        case RegionType.RECTANGLE:
            return "RECTANGLE";
        case RegionType.CIRCLE:
            return "CIRCLE";
        case RegionType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseEmpty() {
    return {};
}
exports.Empty = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmpty();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.Empty.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseEmpty();
        return message;
    },
};
function createBaseStatusResponse() {
    return { status: false, statusMessage: "" };
}
exports.StatusResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== false) {
            writer.uint32(8).bool(message.status);
        }
        if (message.statusMessage !== "") {
            writer.uint32(18).string(message.statusMessage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStatusResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.status = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.statusMessage = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
            statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.status !== false) {
            obj.status = message.status;
        }
        if (message.statusMessage !== "") {
            obj.statusMessage = message.statusMessage;
        }
        return obj;
    },
    create(base) {
        return exports.StatusResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseStatusResponse();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : false;
        message.statusMessage = (_b = object.statusMessage) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseImageDataRequest() {
    return { uuid: "", regionType: 0, start: [], count: [] };
}
exports.ImageDataRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        if (message.regionType !== 0) {
            writer.uint32(16).int32(message.regionType);
        }
        writer.uint32(26).fork();
        for (const v of message.start) {
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(34).fork();
        for (const v of message.count) {
            writer.int32(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseImageDataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.regionType = reader.int32();
                    continue;
                case 3:
                    if (tag === 24) {
                        message.start.push(reader.int32());
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.start.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 4:
                    if (tag === 32) {
                        message.count.push(reader.int32());
                        continue;
                    }
                    if (tag === 34) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.count.push(reader.int32());
                        }
                        continue;
                    }
                    break;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            regionType: isSet(object.regionType) ? regionTypeFromJSON(object.regionType) : 0,
            start: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.start) ? object.start.map((e) => globalThis.Number(e)) : [],
            count: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.count) ? object.count.map((e) => globalThis.Number(e)) : [],
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.regionType !== 0) {
            obj.regionType = regionTypeToJSON(message.regionType);
        }
        if ((_a = message.start) === null || _a === void 0 ? void 0 : _a.length) {
            obj.start = message.start.map((e) => Math.round(e));
        }
        if ((_b = message.count) === null || _b === void 0 ? void 0 : _b.length) {
            obj.count = message.count.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return exports.ImageDataRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseImageDataRequest();
        message.uuid = (_a = object.uuid) !== null && _a !== void 0 ? _a : "";
        message.regionType = (_b = object.regionType) !== null && _b !== void 0 ? _b : 0;
        message.start = ((_c = object.start) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.count = ((_d = object.count) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        return message;
    },
};
function createBaseImageDataResponse() {
    return { rawValuesFp32: new Uint8Array(0), numPixels: 0 };
}
exports.ImageDataResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rawValuesFp32.length !== 0) {
            writer.uint32(10).bytes(message.rawValuesFp32);
        }
        if (message.numPixels !== 0) {
            writer.uint32(16).int32(message.numPixels);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseImageDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rawValuesFp32 = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.numPixels = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rawValuesFp32: isSet(object.rawValuesFp32) ? bytesFromBase64(object.rawValuesFp32) : new Uint8Array(0),
            numPixels: isSet(object.numPixels) ? globalThis.Number(object.numPixels) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rawValuesFp32.length !== 0) {
            obj.rawValuesFp32 = base64FromBytes(message.rawValuesFp32);
        }
        if (message.numPixels !== 0) {
            obj.numPixels = Math.round(message.numPixels);
        }
        return obj;
    },
    create(base) {
        return exports.ImageDataResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseImageDataResponse();
        message.rawValuesFp32 = (_a = object.rawValuesFp32) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.numPixels = (_b = object.numPixels) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseMask() {
    return { mask: [], width: 0, height: 0 };
}
exports.Mask = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.mask) {
            writer.bool(v);
        }
        writer.ldelim();
        if (message.width !== 0) {
            writer.uint32(16).int32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).int32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMask();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag === 8) {
                        message.mask.push(reader.bool());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.mask.push(reader.bool());
                        }
                        continue;
                    }
                    break;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.width = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mask: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.mask) ? object.mask.map((e) => globalThis.Boolean(e)) : [],
            width: isSet(object.width) ? globalThis.Number(object.width) : 0,
            height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.mask) === null || _a === void 0 ? void 0 : _a.length) {
            obj.mask = message.mask;
        }
        if (message.width !== 0) {
            obj.width = Math.round(message.width);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        return obj;
    },
    create(base) {
        return exports.Mask.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMask();
        message.mask = ((_a = object.mask) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.width = (_b = object.width) !== null && _b !== void 0 ? _b : 0;
        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseSpectralProfileRequest() {
    return { uuid: "", regionType: 0, x: 0, y: 0, z: 0, numPixels: 0, width: 0, height: 0 };
}
exports.SpectralProfileRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        if (message.regionType !== 0) {
            writer.uint32(16).int32(message.regionType);
        }
        if (message.x !== 0) {
            writer.uint32(24).int32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(32).int32(message.y);
        }
        if (message.z !== 0) {
            writer.uint32(40).int32(message.z);
        }
        if (message.numPixels !== 0) {
            writer.uint32(48).int32(message.numPixels);
        }
        if (message.width !== 0) {
            writer.uint32(56).int32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(64).int32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpectralProfileRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.regionType = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.x = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.y = reader.int32();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.z = reader.int32();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.numPixels = reader.int32();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.width = reader.int32();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.height = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            regionType: isSet(object.regionType) ? regionTypeFromJSON(object.regionType) : 0,
            x: isSet(object.x) ? globalThis.Number(object.x) : 0,
            y: isSet(object.y) ? globalThis.Number(object.y) : 0,
            z: isSet(object.z) ? globalThis.Number(object.z) : 0,
            numPixels: isSet(object.numPixels) ? globalThis.Number(object.numPixels) : 0,
            width: isSet(object.width) ? globalThis.Number(object.width) : 0,
            height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if (message.regionType !== 0) {
            obj.regionType = regionTypeToJSON(message.regionType);
        }
        if (message.x !== 0) {
            obj.x = Math.round(message.x);
        }
        if (message.y !== 0) {
            obj.y = Math.round(message.y);
        }
        if (message.z !== 0) {
            obj.z = Math.round(message.z);
        }
        if (message.numPixels !== 0) {
            obj.numPixels = Math.round(message.numPixels);
        }
        if (message.width !== 0) {
            obj.width = Math.round(message.width);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        return obj;
    },
    create(base) {
        return exports.SpectralProfileRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseSpectralProfileRequest();
        message.uuid = (_a = object.uuid) !== null && _a !== void 0 ? _a : "";
        message.regionType = (_b = object.regionType) !== null && _b !== void 0 ? _b : 0;
        message.x = (_c = object.x) !== null && _c !== void 0 ? _c : 0;
        message.y = (_d = object.y) !== null && _d !== void 0 ? _d : 0;
        message.z = (_e = object.z) !== null && _e !== void 0 ? _e : 0;
        message.numPixels = (_f = object.numPixels) !== null && _f !== void 0 ? _f : 0;
        message.width = (_g = object.width) !== null && _g !== void 0 ? _g : 0;
        message.height = (_h = object.height) !== null && _h !== void 0 ? _h : 0;
        return message;
    },
};
function createBaseSpectralProfileResponse() {
    return { rawValuesFp32: new Uint8Array(0), counts: new Uint8Array(0) };
}
exports.SpectralProfileResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rawValuesFp32.length !== 0) {
            writer.uint32(10).bytes(message.rawValuesFp32);
        }
        if (message.counts.length !== 0) {
            writer.uint32(18).bytes(message.counts);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpectralProfileResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rawValuesFp32 = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.counts = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rawValuesFp32: isSet(object.rawValuesFp32) ? bytesFromBase64(object.rawValuesFp32) : new Uint8Array(0),
            counts: isSet(object.counts) ? bytesFromBase64(object.counts) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rawValuesFp32.length !== 0) {
            obj.rawValuesFp32 = base64FromBytes(message.rawValuesFp32);
        }
        if (message.counts.length !== 0) {
            obj.counts = base64FromBytes(message.counts);
        }
        return obj;
    },
    create(base) {
        return exports.SpectralProfileResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSpectralProfileResponse();
        message.rawValuesFp32 = (_a = object.rawValuesFp32) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.counts = (_b = object.counts) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        return message;
    },
};
function createBaseHistogramRequest() {
    return { uuid: "", start: [], count: [] };
}
exports.HistogramRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        writer.uint32(18).fork();
        for (const v of message.start) {
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(26).fork();
        for (const v of message.count) {
            writer.int32(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistogramRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 2:
                    if (tag === 16) {
                        message.start.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.start.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 3:
                    if (tag === 24) {
                        message.count.push(reader.int32());
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.count.push(reader.int32());
                        }
                        continue;
                    }
                    break;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            start: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.start) ? object.start.map((e) => globalThis.Number(e)) : [],
            count: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.count) ? object.count.map((e) => globalThis.Number(e)) : [],
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if ((_a = message.start) === null || _a === void 0 ? void 0 : _a.length) {
            obj.start = message.start.map((e) => Math.round(e));
        }
        if ((_b = message.count) === null || _b === void 0 ? void 0 : _b.length) {
            obj.count = message.count.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return exports.HistogramRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseHistogramRequest();
        message.uuid = (_a = object.uuid) !== null && _a !== void 0 ? _a : "";
        message.start = ((_b = object.start) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.count = ((_c = object.count) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
    },
};
function createBaseHistogramDistRequest() {
    return { uuid: "", start: [], count: [], data: [], numBins: 0, binWidth: 0, minValue: 0, maxValue: 0 };
}
exports.HistogramDistRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.uuid !== "") {
            writer.uint32(10).string(message.uuid);
        }
        writer.uint32(18).fork();
        for (const v of message.start) {
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(26).fork();
        for (const v of message.count) {
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(34).fork();
        for (const v of message.data) {
            writer.float(v);
        }
        writer.ldelim();
        if (message.numBins !== 0) {
            writer.uint32(53).sfixed32(message.numBins);
        }
        if (message.binWidth !== 0) {
            writer.uint32(57).double(message.binWidth);
        }
        if (message.minValue !== 0) {
            writer.uint32(65).double(message.minValue);
        }
        if (message.maxValue !== 0) {
            writer.uint32(73).double(message.maxValue);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistogramDistRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.uuid = reader.string();
                    continue;
                case 2:
                    if (tag === 16) {
                        message.start.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.start.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 3:
                    if (tag === 24) {
                        message.count.push(reader.int32());
                        continue;
                    }
                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.count.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 4:
                    if (tag === 37) {
                        message.data.push(reader.float());
                        continue;
                    }
                    if (tag === 34) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.data.push(reader.float());
                        }
                        continue;
                    }
                    break;
                case 6:
                    if (tag !== 53) {
                        break;
                    }
                    message.numBins = reader.sfixed32();
                    continue;
                case 7:
                    if (tag !== 57) {
                        break;
                    }
                    message.binWidth = reader.double();
                    continue;
                case 8:
                    if (tag !== 65) {
                        break;
                    }
                    message.minValue = reader.double();
                    continue;
                case 9:
                    if (tag !== 73) {
                        break;
                    }
                    message.maxValue = reader.double();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
            start: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.start) ? object.start.map((e) => globalThis.Number(e)) : [],
            count: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.count) ? object.count.map((e) => globalThis.Number(e)) : [],
            data: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.data) ? object.data.map((e) => globalThis.Number(e)) : [],
            numBins: isSet(object.numBins) ? globalThis.Number(object.numBins) : 0,
            binWidth: isSet(object.binWidth) ? globalThis.Number(object.binWidth) : 0,
            minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
            maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
        };
    },
    toJSON(message) {
        var _a, _b, _c;
        const obj = {};
        if (message.uuid !== "") {
            obj.uuid = message.uuid;
        }
        if ((_a = message.start) === null || _a === void 0 ? void 0 : _a.length) {
            obj.start = message.start.map((e) => Math.round(e));
        }
        if ((_b = message.count) === null || _b === void 0 ? void 0 : _b.length) {
            obj.count = message.count.map((e) => Math.round(e));
        }
        if ((_c = message.data) === null || _c === void 0 ? void 0 : _c.length) {
            obj.data = message.data;
        }
        if (message.numBins !== 0) {
            obj.numBins = Math.round(message.numBins);
        }
        if (message.binWidth !== 0) {
            obj.binWidth = message.binWidth;
        }
        if (message.minValue !== 0) {
            obj.minValue = message.minValue;
        }
        if (message.maxValue !== 0) {
            obj.maxValue = message.maxValue;
        }
        return obj;
    },
    create(base) {
        return exports.HistogramDistRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseHistogramDistRequest();
        message.uuid = (_a = object.uuid) !== null && _a !== void 0 ? _a : "";
        message.start = ((_b = object.start) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.count = ((_c = object.count) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.data = ((_d = object.data) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.numBins = (_e = object.numBins) !== null && _e !== void 0 ? _e : 0;
        message.binWidth = (_f = object.binWidth) !== null && _f !== void 0 ? _f : 0;
        message.minValue = (_g = object.minValue) !== null && _g !== void 0 ? _g : 0;
        message.maxValue = (_h = object.maxValue) !== null && _h !== void 0 ? _h : 0;
        return message;
    },
};
function createBaseHistogramResponse() {
    return { numBins: 0, binWidth: 0, firstBinCenter: 0, bins: [], mean: 0, stdDev: 0 };
}
exports.HistogramResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.numBins !== 0) {
            writer.uint32(13).sfixed32(message.numBins);
        }
        if (message.binWidth !== 0) {
            writer.uint32(17).double(message.binWidth);
        }
        if (message.firstBinCenter !== 0) {
            writer.uint32(25).double(message.firstBinCenter);
        }
        writer.uint32(34).fork();
        for (const v of message.bins) {
            writer.sfixed32(v);
        }
        writer.ldelim();
        if (message.mean !== 0) {
            writer.uint32(41).double(message.mean);
        }
        if (message.stdDev !== 0) {
            writer.uint32(49).double(message.stdDev);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistogramResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.numBins = reader.sfixed32();
                    continue;
                case 2:
                    if (tag !== 17) {
                        break;
                    }
                    message.binWidth = reader.double();
                    continue;
                case 3:
                    if (tag !== 25) {
                        break;
                    }
                    message.firstBinCenter = reader.double();
                    continue;
                case 4:
                    if (tag === 37) {
                        message.bins.push(reader.sfixed32());
                        continue;
                    }
                    if (tag === 34) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.bins.push(reader.sfixed32());
                        }
                        continue;
                    }
                    break;
                case 5:
                    if (tag !== 41) {
                        break;
                    }
                    message.mean = reader.double();
                    continue;
                case 6:
                    if (tag !== 49) {
                        break;
                    }
                    message.stdDev = reader.double();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            numBins: isSet(object.numBins) ? globalThis.Number(object.numBins) : 0,
            binWidth: isSet(object.binWidth) ? globalThis.Number(object.binWidth) : 0,
            firstBinCenter: isSet(object.firstBinCenter) ? globalThis.Number(object.firstBinCenter) : 0,
            bins: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.bins) ? object.bins.map((e) => globalThis.Number(e)) : [],
            mean: isSet(object.mean) ? globalThis.Number(object.mean) : 0,
            stdDev: isSet(object.stdDev) ? globalThis.Number(object.stdDev) : 0,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.numBins !== 0) {
            obj.numBins = Math.round(message.numBins);
        }
        if (message.binWidth !== 0) {
            obj.binWidth = message.binWidth;
        }
        if (message.firstBinCenter !== 0) {
            obj.firstBinCenter = message.firstBinCenter;
        }
        if ((_a = message.bins) === null || _a === void 0 ? void 0 : _a.length) {
            obj.bins = message.bins.map((e) => Math.round(e));
        }
        if (message.mean !== 0) {
            obj.mean = message.mean;
        }
        if (message.stdDev !== 0) {
            obj.stdDev = message.stdDev;
        }
        return obj;
    },
    create(base) {
        return exports.HistogramResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseHistogramResponse();
        message.numBins = (_a = object.numBins) !== null && _a !== void 0 ? _a : 0;
        message.binWidth = (_b = object.binWidth) !== null && _b !== void 0 ? _b : 0;
        message.firstBinCenter = (_c = object.firstBinCenter) !== null && _c !== void 0 ? _c : 0;
        message.bins = ((_d = object.bins) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.mean = (_e = object.mean) !== null && _e !== void 0 ? _e : 0;
        message.stdDev = (_f = object.stdDev) !== null && _f !== void 0 ? _f : 0;
        return message;
    },
};
function createBaseSpatialProfile() {
    return { start: 0, end: 0, rawValuesFp32: new Uint8Array(0), coordinate: "" };
}
exports.SpatialProfile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.start !== 0) {
            writer.uint32(13).sfixed32(message.start);
        }
        if (message.end !== 0) {
            writer.uint32(21).sfixed32(message.end);
        }
        if (message.rawValuesFp32.length !== 0) {
            writer.uint32(26).bytes(message.rawValuesFp32);
        }
        if (message.coordinate !== "") {
            writer.uint32(34).string(message.coordinate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSpatialProfile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.start = reader.sfixed32();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.end = reader.sfixed32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.rawValuesFp32 = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.coordinate = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet(object.start) ? globalThis.Number(object.start) : 0,
            end: isSet(object.end) ? globalThis.Number(object.end) : 0,
            rawValuesFp32: isSet(object.rawValuesFp32) ? bytesFromBase64(object.rawValuesFp32) : new Uint8Array(0),
            coordinate: isSet(object.coordinate) ? globalThis.String(object.coordinate) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== 0) {
            obj.start = Math.round(message.start);
        }
        if (message.end !== 0) {
            obj.end = Math.round(message.end);
        }
        if (message.rawValuesFp32.length !== 0) {
            obj.rawValuesFp32 = base64FromBytes(message.rawValuesFp32);
        }
        if (message.coordinate !== "") {
            obj.coordinate = message.coordinate;
        }
        return obj;
    },
    create(base) {
        return exports.SpatialProfile.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSpatialProfile();
        message.start = (_a = object.start) !== null && _a !== void 0 ? _a : 0;
        message.end = (_b = object.end) !== null && _b !== void 0 ? _b : 0;
        message.rawValuesFp32 = (_c = object.rawValuesFp32) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.coordinate = (_d = object.coordinate) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
exports.H5ReadersService = {
    checkStatus: {
        path: "/proto.H5Readers/CheckStatus",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.Empty.encode(value).finish()),
        requestDeserialize: (value) => exports.Empty.decode(value),
        responseSerialize: (value) => Buffer.from(exports.StatusResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.StatusResponse.decode(value),
    },
    openFile: {
        path: "/proto.H5Readers/OpenFile",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(OpenFile_1.OpenFileRequest.encode(value).finish()),
        requestDeserialize: (value) => OpenFile_1.OpenFileRequest.decode(value),
        responseSerialize: (value) => Buffer.from(OpenFile_1.OpenFileACK.encode(value).finish()),
        responseDeserialize: (value) => OpenFile_1.OpenFileACK.decode(value),
    },
    closeFile: {
        path: "/proto.H5Readers/CloseFile",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(OpenFile_1.FileCloseRequest.encode(value).finish()),
        requestDeserialize: (value) => OpenFile_1.FileCloseRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.StatusResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.StatusResponse.decode(value),
    },
    getFileInfo: {
        path: "/proto.H5Readers/GetFileInfo",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(FileInfo_1.FileInfoRequest.encode(value).finish()),
        requestDeserialize: (value) => FileInfo_1.FileInfoRequest.decode(value),
        responseSerialize: (value) => Buffer.from(FileInfo_1.FileInfoResponse.encode(value).finish()),
        responseDeserialize: (value) => FileInfo_1.FileInfoResponse.decode(value),
    },
    getImageDataStream: {
        path: "/proto.H5Readers/GetImageDataStream",
        requestStream: false,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(exports.ImageDataRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.ImageDataRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.ImageDataResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.ImageDataResponse.decode(value),
    },
    getSpectralProfile: {
        path: "/proto.H5Readers/GetSpectralProfile",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.SpectralProfileRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.SpectralProfileRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.SpectralProfileResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.SpectralProfileResponse.decode(value),
    },
    getSpectralProfileStream: {
        path: "/proto.H5Readers/GetSpectralProfileStream",
        requestStream: false,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(exports.SpectralProfileRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.SpectralProfileRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.SpectralProfileResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.SpectralProfileResponse.decode(value),
    },
    getHistogram: {
        path: "/proto.H5Readers/GetHistogram",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.HistogramRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.HistogramRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.HistogramResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.HistogramResponse.decode(value),
    },
    getHistogramDist: {
        path: "/proto.H5Readers/GetHistogramDist",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.HistogramDistRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.HistogramDistRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.HistogramResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.HistogramResponse.decode(value),
    },
};
exports.H5ReadersClient = (0, grpc_js_1.makeGenericClientConstructor)(exports.H5ReadersService, "proto.H5Readers");
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
